
#############################################################
#######		veg for Landowner Letters 2018      #########
#############################################################




library(reshape2)
library(ggplot2)
#library(knitr)
library(plyr)

# Set your working directory. This is the pathway to the file where you keep your downloaded data. 
# All products get written to this as well.
# I recommend 1 folder per ranch
# Replace the filepath in quotes with your filepath
# Remember to change the backslashes ("\") to forward slashes ("/")


setwd("//prbo.org/Data/Home/Petaluma/eporzig/Documents/Rangeland/Analysis/LoL2018/ForSuzie2018")  ##

# Read in Veg data
# Replace the filename in quotes with whatever you named the file 

main<-read.csv("BAHImain.csv")
lpi<-read.csv("BAHIlpi.csv")
checklist<-read.csv("BAHIchecklist.csv")

# Read in the California Plants list and Invasivs.  
##These are files you should have gotten from Libby. 
##Bug her if you didn't


CAPlants<-read.csv("CAPlantsv2.csv")
Invasives<-read.csv("Invasivesv1.csv")


##data cleanup to get ready##
main$Date = as.Date(as.character(main$Date), "%m/%d/%Y")
lpi$Date = as.Date(as.character(lpi$Date), "%m/%d/%Y")
checklist$Event.Date = as.Date(as.character(checklist$Event.Date), "%m/%d/%Y")

### Point year

main$year = format(as.Date(main$Date), "%Y")
main$pointyear = as.factor(paste(main$PointId, "-", main$year))
lpi$year = format(as.Date(lpi$Date), "%Y")
lpi$pointyear = as.factor(paste(lpi$Point.Id, "-", lpi$year))
checklist$year = format(as.Date(checklist$Event.Date), "%Y")
checklist$pointyear = as.factor(paste(checklist$Point.Id, "-", checklist$year))


#####Lets just do 2018 here
# main = main[main$Date > as.Date("2018-01-01"),]
# lpi = lpi[lpi$Date > as.Date("2018-01-01"),]
# checklist = checklist[checklist$Event.Date > as.Date("2018-01-01"),]

##remove blank rows
lpi = subset(lpi, subset = Soil.Surface != "")



#################################################################
##		Part 1: Summary of cover table  	#########
#################################################################

# Aggreate cover of trees and shrubs
covsum<- ddply(checklist, .(Vegetation.Type,pointyear), summarise, Percent.Cover=sum(Percent.Cover), .drop=F)
shrubs<-subset(covsum, subset=covsum$Vegetation.Type == "shrubs")
trees<-subset(covsum, subset=covsum$Vegetation.Type == "trees")


###### Calculate bare ground, thatch & litter ###############

lpi$BG<-0
lpi$BG <- replace(lpi$BG, lpi$Top.Layer == "NOPLANT" & lpi$Lower1 == "" & lpi$Lower2 == "" & lpi$Lower3 == "" & lpi$Soil.Surface == "S", 1)

#Aggregate Bare Grounds By Point
BareGround<-aggregate(lpi$BG,list(lpi$pointyear),sum)
names(BareGround)<-c("pointyear", "BareGround")


#Calculate Litter
#First, rename all of the things that could be litter into just one term
lpi$Litter<-0
lpi$Litter <- replace(lpi$Litter, lpi$Lower1 == "L", 1)
lpi$Litter <- replace(lpi$Litter, lpi$Lower2 == "L", 1)
lpi$Litter <- replace(lpi$Litter, lpi$Lower3 == "L", 1)
lpi$Litter <- replace(lpi$Litter, lpi$Lower4 == "L", 1)
lpi$Litter <- replace(lpi$Litter, lpi$Lower5 == "L", 1)
lpi$Litter <- replace(lpi$Litter, lpi$Lower6 == "L", 1)
lpi$Litter <- replace(lpi$Litter, lpi$Lower7 == "L", 1)
lpi$Litter <- replace(lpi$Litter, lpi$Lower8 == "L", 1)
lpi$Litter <- replace(lpi$Litter, lpi$Lower9 == "L", 1)
lpi$Litter <- replace(lpi$Litter, lpi$Lower10 == "L", 1)
lpi$Litter <- replace(lpi$Litter, lpi$Soil.Surface == "L", 1)
lpi$Litter <- replace(lpi$Litter, lpi$Soil.Surface == "EM", 1)

Litter<-aggregate(lpi$Litter,list(lpi$pointyear),sum)
names(Litter)<-c("pointyear", "Litter")

lpi$Thatch<-0
lpi$Thatch<-replace(lpi$Thatch, lpi$Thatch.Indices != "NA", 1)
Thatch<-aggregate(lpi$Thatch,list(lpi$pointyear),sum)
names(Thatch)<-c("pointyear", "Thatch")


###########		Species Richness	##########################

lpi$Point.Dir<-paste(lpi$pointyear, lpi$Direction, sep="-")

layers<-subset(lpi, select=c("pointyear",  "Top.Layer", "Lower1", "Lower2", "Lower3", "Lower4", "Lower5", "Lower6", "Lower7"))

longlpi<-melt(layers, id="pointyear")
names(longlpi)<-c("pointyear", "Layer", "Spp")
checklist$Layer<-"extras"
extras<-subset(checklist, select=c("pointyear", "Layer", "USDA.Code"))
names(extras)<-c("pointyear", "Layer", "Spp")

both<-rbind(longlpi, extras)
both$Spp<-as.factor(both$Spp)

#Remove the non-spp
Exclude<-c("", "2FA", "2FORB", "2FP", "2GA", "2GP", "2LICHN", 
"2LTR", "2LTRWS",  "2PLANT",  "2W", "NOPLANT", "L")
both <- both[!(both$Spp %in% Exclude),]
both<-droplevels(both)


##add plants that are in the soil surface hit to this that## 

richness<-NULL

for (i in levels(both$pointyear)) {
	Point<-both[both$pointyear==i,]
	Point<-subset(Point, !duplicated(Point$Spp))
if (is.null(richness)) {richness<-Point} else {richness<-rbind(richness,Point)}}



richness<-merge(richness, CAPlants, by.x = "Spp", by.y = "Accepted.Symbol", all.x = TRUE, all.y = FALSE)

richness2<-aggregate(richness$Spp, list(richness$pointyear), length)
names(richness2)<-c("pointyear", "NumSpp")


#### Now bring everything together

data.summary<-merge(richness2, Litter, by="pointyear")
data.summary<-merge(data.summary, Thatch,by="pointyear")
data.summary<-merge(data.summary, BareGround,by="pointyear")
data.summary<-merge(data.summary, trees,by="pointyear", all.x=TRUE)
data.summary<-merge(data.summary, shrubs,by="pointyear", all.x=TRUE)


# IF you have transect where Not every point has all 100 subsamples, 
# Then run this to correct for reduced effort

lpi$Tally<-1
a<-aggregate(lpi$Tally, list(lpi$pointyear), sum)
names(a)<-c("pointyear", "NumIndices")

data.summary<-merge(data.summary, a, by="pointyear")
data.summary$Litter<-(data.summary$Litter/data.summary$NumIndices)*100
data.summary$BareGround<-(data.summary$BareGround/data.summary$NumIndices)*100

## Write Summary table to a .csv
write.csv(data.summary, "CoverSummaryTable.csv")

# or to select and write by hand
#write.csv(data.summary, file.choose())


#####
## Making some plots
#####

#Species richness by point
plot(as.numeric(data.summary$pointyear), data.summary$NumSpp, pch=16, xaxt="n", las=1, ylim=c(0,max(data.summary$NumSpp)), xlim=c(0.5,length(as.numeric(data.summary$pointyear))+0.5),
     xlab="Point", cex.main=1.5, ylab="Number of Species", main="Species richness", cex.lab=1)
     
axis(side=1, at=1:nrow(data.summary), labels=levels(data.summary$pointyear))
dev.print(pdf,"SppRich.pdf")




## Bare Ground by Point
plot(as.numeric(data.summary$pointyear), data.summary$BareGround, pch=16, xaxt="n", las=1, ylim=c(0,max(data.summary$BareGround)),xlim=c(0.5,length(as.numeric(data.summary$pointyear))+0.5),
     xlab="Point", cex.main=1.5, ylab="% Bare Ground", main="% Bare Ground", cex.lab=1)
axis(side=1, at=1:nrow(data.summary), labels=levels(data.summary$pointyear))
dev.print(pdf,"BareGround.pdf")


## Litter by Point
plot(as.numeric(data.summary$pointyear), data.summary$Litter, pch=16, xaxt="n", las=1, ylim=c(0,max(data.summary$Litter)),xlim=c(0.5,length(as.numeric(data.summary$pointyear))+0.5),
     xlab="Point", cex.main=1.5, ylab="% Litter", main="% Litter", cex.lab=1)
axis(side=1, at=1:nrow(data.summary), labels=levels(data.summary$pointyear))
dev.print(pdf,"Litter.pdf")


## Thatch by Point 
plot(as.numeric(data.summary$pointyear), data.summary$Thatch, pch=16, xaxt="n", las=1, ylim=c(0,max(data.summary$Thatch)),xlim=c(0.5,length(as.numeric(data.summary$pointyear))+0.5),
     xlab="Point", cex.main=1.5, ylab="% Thatch", main="% Thatch", cex.lab=1)
axis(side=1, at=1:nrow(data.summary), labels=levels(data.summary$pointyear))


################################################################				
########	  Part 2:  Making the Species List	 #######
################################################################

SppList<-subset(richness, select=c("Spp", "Symbol", "Scientific.Name", "Common.Name","Genus","Family","Family.Common.Name",
"Duration","Growth.Habit", "Native.Status" ,"Invasive", "FunGrp"))
    
SppList<-subset(SppList, !duplicated(SppList$Spp))



#####
## Make a cover table with Invasives
#####



CAPlantsI<-CAPlants
levels(CAPlantsI$FunGrp) <- c(levels(CAPlantsI$FunGrp), "Invasives")

CAPlantsI$FunGrp[CAPlantsI$Accepted.Symbol %in% Invasives$USDA.code]<-"Invasives"

#########################################################
######

SppList$Native.Status<-substr(SppList$Native.Status, 1, 7)

##### Make a Native/Invasive category
SppList$Provenance<-NULL
SppList$Provenance <- replace(SppList$Provenance, SppList$Native.Status == "L48 (N)", "Native")
SppList$Provenance <- replace(SppList$Provenance, SppList$Native.Status == "L48 (I)", "Non-native")


## Write species list to a .csv
write.csv(SppList, "PlantSpeciesList.csv")

#SppList2<-subset(SppList, select=c("Scientific.Name", "Common.Name", "Family", "Provenance", "FunGrp"))


###########################################################################
#######       Part 3: % cover of  species    ####################
###########################################################################

## This creates a table with SPP Id across the top and proportion of cover in the cells, by point

## Step 1. In a separate table, calculate the total number of Point.Index 
## per point

lpi$Tally<-1

a<-aggregate(lpi$Tally, list(lpi$pointyear), sum)
names(a)<-c("pointyear", "NumIndices")


## Step 2: limit fields to pointyear, and all of the layers.
## reshape so you have a point field and then all of the plants

lpi.trim<-subset(lpi, select=c("pointyear", "Canopy1", "Canopy2","Canopy3","Top.Layer","Lower1","Lower2", "Lower3", "Lower4","Lower5","Lower6","Lower7", "Lower8","Lower9","Lower10","Soil.Surface"))

longlpi<-melt(lpi.trim, id="pointyear")
# Note, this step may give a warning, but it's okay
names(longlpi)<-c("pointyear", "Layer", "Spp")

longlpi<-subset(longlpi, select=c("pointyear", "Spp"))
longlpi$Tally<-1

newlpi<-dcast(longlpi, pointyear~Spp,value.var=c("Tally"), sum)
newlpi<-merge(newlpi, a, by="pointyear")
pointyear<-newlpi$pointyear
newlpi.relative<-(newlpi[,3:ncol(newlpi)-1]/newlpi$NumIndices) *100
newlpi.relative<-cbind(pointyear, newlpi.relative)

## Almost there, just some tidying

drops<-c("Var.2", "2FA", "2FORB", "2FP", "2FS", "2GA", "2GP", "2LICHN", "2LTR", "2LTRWS", "2MOSS", "2PLANT", 
"2W", "NA", "NumIndices", "NOPLANT", "UNKNWN", "M", "L", "EM", "AM", "R", "WL", "S")
newlpi.relative <- newlpi.relative[,!(names(newlpi.relative) %in% drops)]
newlpi <- newlpi[,!(names(newlpi) %in% drops)]


### Write the table to a .csv  
write.csv(newlpi.relative, "LPIsummary.csv")

# or to write by hand
#write.csv(newlpi.relative, file.choose())


#############################################################################################################
#########  Part 4, Version 1: Make the same table as in part 3, but functional groups instead of species. Invasive not a Functional Group##### 
#############################################################################################################


# replace list in Longlpi with functional groups
longlpi$FunGrp<-NULL
longlpi$FunGrp<-CAPlants$FunGrp[match(longlpi$Spp,CAPlants$Accepted.Symbol)]
Fun.Sum<-aggregate(longlpi$Tally, list(longlpi$pointyear, longlpi$FunGrp), sum)
names(Fun.Sum)<-c("pointyear", "FunGrp", "Count")
Fun.Sum2<-dcast(Fun.Sum, pointyear~FunGrp,value.var=c("Count"), sum)
Fun.Sum2<-merge(Fun.Sum2, a, by="pointyear")
pointyear<-Fun.Sum2$pointyear
Fun.Sum2.relative<-(Fun.Sum2[,2:ncol(Fun.Sum2)]/Fun.Sum2$NumIndices) *100
Fun.Sum2.relative<-cbind(pointyear, Fun.Sum2.relative)
Fun.Sum2.relative$TotalCover<-rowSums(Fun.Sum2.relative[,2:(ncol(Fun.Sum2.relative)-1)], na.rm=TRUE)

Fun.Sum2.relative[,2:(ncol(Fun.Sum2.relative)-1)]<-Fun.Sum2.relative[,2:(ncol(Fun.Sum2)-1)]/Fun.Sum2.relative$TotalCover    




#########  Part 4, Version 2: Make the same table as in part 3, but functional groups instead of species. Invasive as a fun grp  ##############
#############################################################################################################


# replace list in Longlpi with functional groups
longlpi2<-longlpi
longlpi2$FunGrp<-NULL
longlpi2$FunGrp<-CAPlantsI$FunGrp[match(longlpi2$Spp,CAPlantsI$Accepted.Symbol)]
Fun.SumI<-aggregate(longlpi2$Tally, list(longlpi2$pointyear, longlpi2$FunGrp), sum)
names(Fun.SumI)<-c("pointyear", "FunGrp", "Count")
Fun.SumI2<-dcast(Fun.SumI, pointyear~FunGrp,value.var=c("Count"), sum)
Fun.SumI2<-merge(Fun.SumI2, a, by="pointyear")
pointyear<-Fun.SumI2$pointyear
Fun.SumI2.relative<-(Fun.SumI2[,2:ncol(Fun.SumI2)]/Fun.SumI2$NumIndices) *100
Fun.SumI2.relative<-cbind(pointyear, Fun.SumI2.relative)
Fun.SumI2.relative$TotalCover<-rowSums(Fun.SumI2.relative[,2:(ncol(Fun.SumI2.relative)-1)], na.rm=TRUE)

Fun.SumI2.relative[,2:(ncol(Fun.SumI2.relative)-1)]<-Fun.SumI2.relative[,2:(ncol(Fun.SumI2)-1)]/Fun.SumI2.relative$TotalCover    







#################################################################################################################
##########  Part Awesome: Making Graphs		#################################################################
#################################################################################################################



p<-Fun.Sum2.relative[,1:(ncol(Fun.Sum2.relative)-2)]
p<-melt(p, id="pointyear")
# Note, this step may give a warning, but it's okay
names(p)<-c("pointyear", "Type", "Cover")


g <- ggplot(p, aes(pointyear, Cover))
#g + geom_col(aes(fill = Type))

g+
geom_col(aes(fill = Type), position = position_stack(reverse = TRUE)) +
 coord_flip() +
 theme(legend.position = "top") + 
  theme(legend.text = element_text(size=8)) +
  theme(legend.title = element_blank()) +
  scale_fill_brewer(palette="Dark2")
dev.print(pdf,"CommunityNoInvasive.pdf")  



###
pI<-Fun.SumI2.relative[,1:(ncol(Fun.SumI2.relative)-2)]
pI<-melt(pI, id="pointyear")
# Note, this step may give a warning, but it's okay
names(pI)<-c("pointyear", "Type", "Cover")


g <- ggplot(pI, aes(pointyear, Cover))
#g + geom_col(aes(fill = Type))

g+
geom_col(aes(fill = Type), position = position_stack(reverse = TRUE)) +
 coord_flip() +
 theme(legend.position = "top") + 
  theme(legend.text = element_text(size=8)) +
  theme(legend.title = element_blank()) +
  scale_fill_brewer(palette="Dark2")


### Write the table to a .csv  
write.csv(Fun.Sum2.relative, "LPIsummaryFun.csv")

# or to write by hand
#write.csv(Fun.Sum2.relative, file.choose())
### Write the table to a .csv  
write.csv(Fun.SumI2.relative, "LPIsummaryFun_wInvasive.csv")

dev.print(pdf,"CommunitywithInvasive.pdf")  






## This is Mel's code that plots two years of veg functional groups. It's not fully 

library(tidyr)

#using previous output Fun.Sum2, add PointID and Year column back in from main
write.csv(Fun.Sum2, file.choose())

#in excel manually add back in point and year columns b/c there were errors in R (130 vs 128 rows)
data<-read.csv("Fun.Sum2.csv")
data1<-data[["NumIndices"]] <-NULL
#gives error, doesn't matter. Check data spreadsheet to ensure NumIndices was removed. 

#gather to long format so we can plot
data.long<-gather(data,FunctionalGroup,Value,"Annual.Forb":"ShrubsTrees",factor_key=TRUE)

#plot
p<-ggplot(data.long, aes(fill=FunctionalGroup, y=Value, x=Year)) + 
  geom_bar( stat="identity", position="fill")
p+labs(y="Proportion",x="Year")


