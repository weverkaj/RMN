#' @title Create a table of cover for functional groups at each point
#'
#' @description For veg data, summarizes cover of each functional group at each point.
#'
#' @param lpi A dataframe object of lpi data from a veg survey
#' @param type Type of cover to calculate - either "absolute" or "relative"
#' @param invasives Boolean that specifies whether to count invasive species as a separate functional group
#'
#' @return A dataframe summary of cover of functional groups
#'
#' @examples data = functional.cover.table(lpi, type = "absolute")
#'
#' @export functional.cover.table
#'
#'
#'


functional.cover.tablet = function(lpi, type = "absolute", invasives = FALSE){
  
  CAPlants = RMN:::CAPlantsv2
  Invasives = RMN:::Invasivesv1
  lpi$Tally = 1
  
  
  CAPlantsI<-CAPlants
  levels(CAPlantsI$FunGrp) <- c(levels(CAPlantsI$FunGrp), "Invasives")
  
  CAPlantsI$FunGrp[CAPlantsI$Accepted.Symbol %in% Invasives$USDA.code]<-"Invasives"
  
  
  a = aggregate(lpi$Tally, list(lpi$pointyear), sum)
  names(a) = c("pointyear", "NumIndices")
  
  lpi.trim = subset(lpi, select=c("pointyear", "year", "Point.Id", "Canopy1", "Canopy2", "Canopy3",
                                  "Top.Layer","Lower1","Lower2", "Lower3", "Lower4","Lower5","Lower6","Lower7",
                                  "Lower8","Lower9","Lower10","Soil.Surface"))
  
  longlpi = melt(lpi.trim, id=c("pointyear", "Point.Id", "year"))
  # Note, this step may give a warning, but it's
  names(longlpi) = c("pointyear", "Point.Id", "year", "Layer", "Spp")
  
  longlpi = subset(longlpi, select=c("pointyear", "Point.Id", "year", "Spp"))
  longlpi$Tally = 1
  
  
  longlpi$FunGrp = NULL
  if(invasives){
    longlpi$FunGrp<-CAPlantsI$FunGrp[match(longlpi$Spp,CAPlantsI$Accepted.Symbol)]
  } else if(!invasives){
    longlpi$FunGrp = CAPlants$FunGrp[match(longlpi$Spp,CAPlants$Accepted.Symbol)]
  } else {stop("Argument for invasives not recognized")}
  
  
  Fun.Sum = aggregate(longlpi$Tally, list(longlpi$pointyear, longlpi$FunGrp), sum)
  names(Fun.Sum) = c("pointyear", "FunGrp", "Count")
  
  Fun.Sum2 = dcast(Fun.Sum, pointyear ~ FunGrp, value.var = c("Count"), sum)
  Fun.Sum2 = merge(Fun.Sum2, a, by = "pointyear")
  pointyear = as.data.frame(Fun.Sum2$pointyear)
  colnames(pointyear) = "pointyear"
  
  
  
  
  Fun.Sum3 = Fun.Sum2
  if(type == "absolute"){
    Fun.Sum3[,2:(ncol(Fun.Sum3) - 1)] = Fun.Sum3[,2:(ncol(Fun.Sum3) - 1)]/Fun.Sum3[,ncol(Fun.Sum3)] * 100
  } else if(type == "relative"){
    Fun.Sum3[,2:(ncol(Fun.Sum3) - 1)] = Fun.Sum3[,2:(ncol(Fun.Sum3) - 1)]/rowSums(Fun.Sum3[,2:(ncol(Fun.Sum3) - 1)], na.rm = TRUE) * 100
  } else {stop("Argument for type not recognized")}
  
  
  
  return(Fun.Sum3)
  
}
